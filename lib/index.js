// Generated by CoffeeScript 1.6.3
var JavaScriptPreprocess, fs;

fs = require("fs");

module.exports = JavaScriptPreprocess = (function() {
  JavaScriptPreprocess.prototype.brunchPlugin = true;

  JavaScriptPreprocess.prototype.type = 'javascript';

  JavaScriptPreprocess.prototype.extension = 'js';

  JavaScriptPreprocess.prototype.statementStack = [];

  function JavaScriptPreprocess(config) {
    this.config = config;
    null;
  }

  JavaScriptPreprocess.prototype.compile = function(data, path, callback) {
    var lastIndex, matchedStmt, stmt, strAfter, strAfterStatement, strBefore, strBeforeStatement, _i, _j, _len, _len1, _ref, _ref1;
    while (matchedStmt = this.getNextStatement(data)) {
      strBeforeStatement = data.substring(0, matchedStmt.index);
      strAfterStatement = data.substring(matchedStmt.index + matchedStmt.statementLength, data.length).trim();
      data = strBeforeStatement + strAfterStatement;
      switch (matchedStmt.statement) {
        case 'if':
          matchedStmt.match = this.evaluateTarget(this.config.buildTarget, matchedStmt.target);
          this.statementStack.push(matchedStmt);
          break;
        case 'elif':
          matchedStmt.match = true;
          _ref = this.statementStack;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stmt = _ref[_i];
            if (stmt.match) {
              matchedStmt.match = false;
              break;
            }
          }
          if (matchedStmt.match) {
            matchedStmt.match = this.evaluateTarget(this.config.buildTarget, matchedStmt.target);
          }
          this.statementStack.push(matchedStmt);
          break;
        case 'else':
          matchedStmt.match = true;
          _ref1 = this.statementStack;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            stmt = _ref1[_j];
            if (stmt.match) {
              matchedStmt.match = false;
              break;
            }
          }
          this.statementStack.push(matchedStmt);
          break;
        case 'endif':
          lastIndex = matchedStmt.index;
          while (this.statementStack.length > 0) {
            stmt = this.statementStack.pop();
            if (!stmt.match) {
              strBefore = data.substring(0, stmt.index);
              strAfter = data.substring(lastIndex, data.length);
              data = strBefore + strAfter;
            }
            lastIndex = stmt.index;
          }
      }
    }
    return callback(null, {
      data: data
    });
  };

  JavaScriptPreprocess.prototype.evaluateTarget = function(buildTarget, evalTarget) {
    var target, targets, _i, _len;
    targets = evalTarget.split('||');
    for (_i = 0, _len = targets.length; _i < _len; _i++) {
      target = targets[_i];
      target = target.trim();
      if (buildTarget === target) {
        return true;
      }
    }
    return false;
  };

  JavaScriptPreprocess.prototype.getNextStatement = function(data) {
    var lastStmt, lastStmtIndex, matchElif, matchElse, matchEndif, matchIf, nextIndex, nextStmtObj, regexElif, regexElse, regexEndif, regexIf, statementLength;
    regexIf = /\/\/ #BRUNCH_IF \((.*?)\)\s/;
    regexElse = /\/\/ #BRUNCH_ELSE/;
    regexElif = /\/\/ #BRUNCH_ELIF \((.*?)\)\s/;
    regexEndif = /\/\/ #BRUNCH_ENDIF/;
    lastStmtIndex = 0;
    lastStmt = this.getTopElement(this.statementStack);
    if (lastStmt) {
      lastStmtIndex = lastStmt.index;
    }
    matchIf = regexIf.exec(data);
    matchElse = regexElse.exec(data);
    matchElif = regexElif.exec(data);
    matchEndif = regexEndif.exec(data);
    nextStmtObj = null;
    nextIndex = Number.POSITIVE_INFINITY;
    statementLength = 0;
    if (matchIf && matchIf.index > lastStmtIndex && matchIf.index < nextIndex) {
      nextIndex = matchIf.index;
      nextStmtObj = {
        statement: 'if',
        statementLength: matchIf[0].length,
        index: matchIf.index,
        target: matchIf[1]
      };
    }
    if (matchElse && matchElse.index > lastStmtIndex && matchElse.index < nextIndex) {
      nextIndex = matchElse.index;
      nextStmtObj = {
        statement: 'else',
        statementLength: matchElse[0].length,
        index: matchElse.index
      };
    }
    if (matchElif && matchElif.index > lastStmtIndex && matchElif.index < nextIndex) {
      nextIndex = matchElif.index;
      nextStmtObj = {
        statement: 'elif',
        statementLength: matchElif[0].length,
        index: matchElif.index,
        target: matchElif[1]
      };
    }
    if (matchEndif && matchEndif.index > lastStmtIndex && matchEndif.index < nextIndex) {
      nextIndex = matchEndif.index;
      nextStmtObj = {
        statement: 'endif',
        statementLength: matchEndif[0].length,
        index: matchEndif.index
      };
    }
    if (!nextStmtObj && lastStmt) {
      throw new Error('Malformed brunch preprocess conditional. ' + lastStmt.statement + ' statement not closed');
    }
    return nextStmtObj;
  };

  JavaScriptPreprocess.prototype.getTopElement = function(arr) {
    var lastIndex;
    lastIndex = arr.length - 1;
    if (lastIndex >= 0) {
      return arr[lastIndex];
    } else {
      return null;
    }
  };

  return JavaScriptPreprocess;

})();
